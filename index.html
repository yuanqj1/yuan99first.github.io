<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="坚持">
<meta property="og:type" content="website">
<meta property="og:title" content="Slurm">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Slurm">
<meta property="og:description" content="坚持">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="study slurm">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Slurm</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Slurm</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/15/aaa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="study slurm">
      <meta itemprop="description" content="坚持">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Slurm">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/aaa/" class="post-title-link" itemprop="url">aaa</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-15 22:29:41 / 修改时间：22:57:36" itemprop="dateCreated datePublished" datetime="2022-11-15T22:29:41+08:00">2022-11-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Slurm集群调度策略详解（1）-主调度"><a href="#Slurm集群调度策略详解（1）-主调度" class="headerlink" title="Slurm集群调度策略详解（1）-主调度"></a><strong>Slurm集群调度策略详解（1）-主调度</strong></h1><h1 id="HPC高性能集群"><a href="#HPC高性能集群" class="headerlink" title="HPC高性能集群"></a>HPC高性能集群</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>高性能集群一般由计算单元，高速存储，高速计算网络，管理网络，操作系统，监控系统，管理系统等多个软件硬件组合而成。从资源管理系统的角度，高性能集群中的节点资源按逻辑功能可分为管理节点、登录节点、计算节点和存储节点；节点之间通过网络联接。如下图</p>
<p><img src="/.com//sched1.png" alt="sched1.png"></p>
<img src="/.com//sched1.png" width="50%" height="50%" title="拼写检查工具Grammarly." alt="拼写检查工具Grammarly.">

<p><strong>登陆节点</strong>：和普通用户交互的主要节点。主要用来接受用户的 ssh 连接和文件传送，同时可以用来编译程序，修改代码和通过任务管理系统提交任务到计算节点。登陆节点还负责 VPN 对接外网对流量分流实现负载均衡、普通的用来浏览文件编译程序提交任务和负责高带宽大文件传输的专用节点等。</p>
<p><strong>管理节点</strong>：普通用户无法登陆，一般具有单独的管理网络，作业管理，资源分配等功能。还可细分为提供资源管理软件，提供账户管理，提供数据库后端，提供监控软件后端等不同功能的节点。分类越细，高可用就越好。每一种功能，还可以进一步包括主节点和备用从节点，从而防止单点故障。</p>
<p><strong>计算节点</strong>：用来进行计算任务的节点，占据了集群中的绝大多数节点。还可细分为不同硬件特性的计算节点。比如大内存节点用来解决内存瓶颈的问题，现在最大内存可达 3T。又比如多 GPU节点，用来进行机器学习等任务。还有具有本地固态硬盘的节点，用来满足需要高速 IO 的计算任务的需求等等。</p>
<p><strong>存储节点</strong>：通过网络文件系统，共享给登陆节点和计算节点使用。通常与这些节点通过高速互联网络，比如 <code>InfiniBand</code> 相连接，带给用户调用本地文件的速度。还可细分为存储元数据的节点，存储文件内容的节点，备份数据的节点等。</p>
<h2 id="调度系统架构"><a href="#调度系统架构" class="headerlink" title="调度系统架构"></a>调度系统架构</h2><p>集群建好之后为了防止资源不受控制,则需要引入调度系统来进行统一的管理，目前市面上主流调度器有四大流派: LSF&#x2F;SGE&#x2F;Slurm&#x2F;PBS。调度系统是面向集群的操作系统，其本质是解决资源请求的无限性和资源的有限性之间的矛盾；典型的调度系统架构如下</p>
<ul>
<li><p>主控服务Server：主要负责资源和作业的监控和管理功能。 </p>
</li>
<li><p>调度服务Scheduler：主要负责定义和执行调度策略，包括配额管理。 </p>
</li>
<li><p>计算代理Agent：主要负责监控资源状态，以及作业的启停和监控。 </p>
</li>
<li><p>存储服务Database：主要负责用户和作业信息的存储 。</p>
</li>
<li><p>访问接口：用户访问系统的统一入口，通常有 cli 工具 、rest api等。</p>
</li>
</ul>
<p><img src="/.com//个人博客\MyBlog\source_posts\aaa\sched2.png" alt="sched2"></p>
<h2 id="常见调度策略"><a href="#常见调度策略" class="headerlink" title="常见调度策略"></a>常见调度策略</h2><p>调度服务解决各种细节问题的实现方法称之为调度算法或调度策略。常见的各种调度算法：先到先服务、短作业优先、多因子优先级、抢占策略、高响应比、时间片轮转等。</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务</td>
<td>每次调度都是从排队作业队列中选择一个或多个最先进入该队列的作业</td>
</tr>
<tr>
<td>短作业优先</td>
<td>设定一个作业窗口，优先调度作业窗口内作业运行时间最短的作业</td>
</tr>
<tr>
<td>非抢占式高优先级调度</td>
<td>调度前会对所有排队作业按照优先级进行排序，调度时会按照优先级从高到底的顺序调度作业，只要作业启动，该作业便一直执行下去，直到执行完成</td>
</tr>
<tr>
<td>抢占式高优先级调度</td>
<td>这种方式同样在调度前会对所有排队作业按照优先级进行排序，调度时会按照优先级从高到底的顺序调度作业，但在作业执行期间，只要又出现了另一个优先级更高的作业，作业调度程序就立即取消或者挂起当前运行作业(原优先权最高的作业)的执行，重新将资源分配给新到的优先级最高的作业。</td>
</tr>
<tr>
<td>高响应比优先调度算法</td>
<td>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。可以通过引入动态优先级算法，作业随着等待时间增加而增加作业的优先级，从而保证了长作业在等待一定时间后能够得到调度</td>
</tr>
<tr>
<td>时间片轮转法</td>
<td>系统将所有的就绪进程按先来先服务的原则排成一个队列，每个作业都能够执行，但是在一个时间片内只能执行一个或几个作业，时间片一到，便切换到下一个作业运行，这样就可以保证在给定的时间内所有作业能运行。</td>
</tr>
<tr>
<td>多级反馈队列调度算法</td>
<td>是目前操作系统调度算法中被公认的一种较好的调度算法。它可以满足各种类型进程的需要，既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。</td>
</tr>
</tbody></table>
<p>在集群作业和计算资源的调度中除了以上的先来先服务，高优先级，抢占等还有公平调度、资源预留、回填调度等。</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公平调度</td>
<td>每个用户设定不同的权重，一个作业的优先级与用户数量、用户权重以及该用户运行的作业数决定，从用户的角度考虑的公平原则</td>
</tr>
<tr>
<td>资源预留</td>
<td>在集群使用过程中可以单独拿出一批资源根据需要设置预留，预留时要设置预留的时间段，资源数量，允许提交的用户以及预留类型，预留的资源只能被指定的指定用户使用，且预留资源不再参与该分区其他用户作业的调度。</td>
</tr>
<tr>
<td>回填调度</td>
<td>由于资源的有限性可能会给高优先级作业在未来一段时间预留资源，这时空闲资源预留会造成资源浪费，而回填调度在不延迟任何较高优先级作业运行的前提下，会尝试低优先级的作业能否回填掉空闲资源上运行，提高资源利用率。</td>
</tr>
</tbody></table>
<h1 id="slurm集群调度系统"><a href="#slurm集群调度系统" class="headerlink" title="slurm集群调度系统"></a>slurm集群调度系统</h1><p>Slurm是一个开源，高度可扩展的集群管理工具和作业调度系统，可以简单理解为一个多机的资源和任务管理系统。主要以下提供三种关键功能：</p>
<p><strong>资源分配：</strong>在特定时间段内为用户分配计算资源，进行独占或非独占访问权限，以便他们可以执行作业。简单的说就是为用户作业提供对计算资源的授权和分配。</p>
<p><strong>作业管理：</strong>它提供了对节点上的作业节进行启动、执行和监控作业的框架。</p>
<p><strong>作业调度：</strong>通过管理待处理作业的队列来仲裁资源的争用。例如根据优先级或不同当调度策略调整资源的分配顺序。</p>
<p>Slurm调度系统中针对作业的调度主要有三种，主调度，回填调度，GANG调度，这篇文章主要针对主调度进行解析。</p>
<h2 id="主调度介绍"><a href="#主调度介绍" class="headerlink" title="主调度介绍"></a>主调度介绍</h2><p>Slurm旨在对作业提交或完成以及配置更改等事件执行快速而简单的调度尝试（非全量调度）。在这些事件触发的调度事件期间，将考虑default_queue_depth(默认值为100)数量的作业。在由sched_interval定义的较低频率间隔中，将考虑对所有作业进行调度。在这两种情况下，一旦一个分区中的任何作业或作业数组任务处于排队状态，该分区中的任何其他作业都不会被调度。一个更全面的调度尝试通常由回填调度插件完成。</p>
<h1 id="主调度参数"><a href="#主调度参数" class="headerlink" title="主调度参数"></a>主调度参数</h1><p>SchedulerType配置参数指定要使用的调度器插件。选项有sched&#x2F;backfill(执行回填调度)和sched&#x2F;builtin(试图在每个分区&#x2F;队列中严格按照优先级顺序调度作业)。还有一个SchedulerParameters配置参数，可以指定范围很广的参数，如下表所述。</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>sched_interval</td>
<td>控制两次全量调度之间的间隔时间，默认值是60秒。设置为-1将禁用主调度循环。</td>
</tr>
<tr>
<td>max_sched_time</td>
<td>主调度循环在退出之前最多执行多长时间(以秒为单位)。如果配置了一个值，请注意所有其他Slurm操作将在此时间段内被推迟。确保该值低于MessageTimeout的一半才会有效。主调度时间不宜过长，2-3秒合适</td>
</tr>
<tr>
<td>default_queue_depth</td>
<td>调度作业队列的深度，当一个正在运行的作业完成或发生其他例行操作时，尝试调度的默认作业数(即队列深度)，此参数在slurm19版本和slurm20版本的使用有所区别，默认值为100个任务。由于这种情况经常发生，所以相对较小的数目通常是最好的。</td>
</tr>
<tr>
<td>partition_job_depth</td>
<td>在Slurm的主调度逻辑中，从每个分区&#x2F;队列尝试调度的默认作业数(即队列深度)，同上如果太小导致后面其他用户作业调度不上，设置太大导致只调度一个分区其他分区饿死，此参数的处理代码slurm19版本和slurm20版本也有所区别，19版本当分区调度作业数量到达限制之后不会改变作业状态，但是20版本会改变作业状态</td>
</tr>
<tr>
<td>sched_min_interval</td>
<td>主调度循环执行和测试排队作业的频率，单位为微秒。调度程序在每次可能启动作业的事件(例如作业提交、作业终止等)发生时都以有限的方式运行。如果这些事件以很高的频率发生，调度器可以非常频繁地运行，如果不使用此选项，则会消耗大量资源。此选项指定从一个调度周期结束到下一个调度周期开始之间的最短时间。值为0将禁用调度逻辑间隔的限制。缺省值是2微秒。</td>
</tr>
<tr>
<td>assoc_limit_stop</td>
<td>如果设置，作业由于关联限制而无法启动，那么将作业所在分区加入分区黑名单，不要尝试在该分区中启动任何低优先级的作业。设置该值会降低系统吞吐量和利用率，但可以防止低优先级作业运行导致高优先级作业饿死。</td>
</tr>
<tr>
<td>defer</td>
<td>如果设置则不要尝试在作业提交或有作业运行完成时单独调度作业。对于高吞吐量计算非常有用，当同时提交大量作业时<strong>，</strong>可以提高系统响应能力，但它将延迟单个作业的启动时间。</td>
</tr>
<tr>
<td>bf_min_age_reserve</td>
<td>回填调度预留时间参数，当高优先级作业因空闲资源未成功运行，且排队的时间不满足bf_min_age_reserve回填预留的条件，则主调度不会将该作业所在分区加入分区黑名单</td>
</tr>
<tr>
<td>bf_min_prio_reserve</td>
<td>回填调度预留优先级参数，当高优先级作业因空闲资源未成功运行，同时作业优先级不满足bf_min_prio_reserve回填预留的条件，则主调度不会将该作业所在分区加入分区黑名单</td>
</tr>
<tr>
<td>batch_sched_delay</td>
<td>批处理作业的调度可以延迟多长时间，单位为秒。这在高吞吐量的环境中非常有用，在这种环境中，批处理作业以非常高的速率提交(即使用sbatch命令)，并且希望减少在提交时调度每个作业的开销。缺省值为3秒。</td>
</tr>
<tr>
<td>sched_max_job_start</td>
<td>主调度逻辑在任何一次执行中启动的作业的最大数量。默认值为0，没有限制。</td>
</tr>
</tbody></table>
<p><strong>分区黑名单</strong>：由于主调度会优先保证高优先级作业的运行，所以当一个高优先级作业因为空闲资源不足而未能运行，调度系统会将作业所在分区拉入分区黑名单，后续该分区低优先级的作业不能再参与调度，但是这些作业会累加到调度默认队列深度和分区作业深度</p>
<h1 id="主调度流程"><a href="#主调度流程" class="headerlink" title="主调度流程"></a>主调度流程</h1><p>slurm调度流程分为两种sched&#x2F;builtin和sched&#x2F;backfill，</p>
<p>sched&#x2F;builtin：按顺序依次调度，这种调度类型按照PriorityType的设置分为两种，当设置priority&#x2F;basic时是按照作业提交时间的顺序也就是FIFO调度作业，当设置priority&#x2F;multifactor时它按优先级顺序调度作业，而作业最终优先级会考虑多种因素，其计算方式如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//When not FIFO scheduling, jobs are prioritized in the following order:</span></span><br><span class="line"><span class="comment">//1. Jobs that can preempt</span></span><br><span class="line"><span class="comment">//2. Jobs with an advanced reservation</span></span><br><span class="line"><span class="comment">//3. Partition PriorityTier</span></span><br><span class="line"><span class="comment">//4. Job priority</span></span><br><span class="line"><span class="comment">//5. Job submit time</span></span><br><span class="line"><span class="comment">//6. Job ID</span></span><br><span class="line">Job_priority = </span><br><span class="line">    site_factor +</span><br><span class="line">    (PriorityweightAge) * (age_factor) +</span><br><span class="line">    (PriorityweightAssoc) * (assoc_factor) +</span><br><span class="line">    (PriorityweightFairshare) * (fair-share_factor)+</span><br><span class="line">    (PriorityweightJobSize) * (job_size_factor)+</span><br><span class="line">    (PriorityweightPartition) * (partition_factor) +</span><br><span class="line">    (PriorityWeightQOS) * (QOS_factor) +</span><br><span class="line">    SUM (TRES_weight_cpu * TRES_factor_cpu,</span><br><span class="line">         TRES_weight_&lt;type&gt; * TRES_factor_&lt;type&gt;,</span><br><span class="line">         ...)</span><br><span class="line">    - nice_factor</span><br></pre></td></tr></table></figure>

<p>如果分区中的任何作业不能被调度，则该分区中的任何低优先级作业都不会被调度。由于分区限制(例如，时间限制)或关闭&#x2F;耗尽节点而不能运行的作业是一个例外。在这种情况下，低优先级的作业可以被启动，而不会影响高优先级的作业。</p>
<p>sched&#x2F;backfill：用于回填调度模块，以扩充默认的主调度。回填调度将启动低优先级作业，如果这样做不延迟任何高优先级作业的预期启动时间。回填调度的有效性取决于用户设定作业时限，否则所有作业的时限相同，无法回填。为了提高调度效率一般集群都会配置sched&#x2F;backfill</p>
<h2 id="作业筛选流程"><a href="#作业筛选流程" class="headerlink" title="作业筛选流程"></a>作业筛选流程</h2><p>作业调度之前，调度系统会对所有主调度相关的参数进行解析，且将所有排队的作业按照优先级从高到低的顺序进行排序并构建作业队列，调度时作业会按照优先级从高到低的顺序出栈，出栈后的作业会经过调度参数和作业自身限制的筛选，最终进入调度作业节点选择启动环节如下图所示。</p>
<p><img src="/.com//个人博客\MyBlog\source_posts\aaa\sched3.png" alt="sched3"></p>
<p>在调度参数限制相关的判断中，会对调度时间、本次调度启动的作业数量、本次调度的作业数量、每个分区调度的作业数量、调度系统最大rpc数量、hetjob作业等进行判断，其中分区到达设定数值之后会修改作业排队状态直接跳过当前作业的调度过程，调度时间、本次调度启动的作业数量、调度系统最大rpc数量和本次调度的作业数量到达限制之后会直接退出本次调度。</p>
<p>除了调度参数限制相关的判断还有作业本身限制的判断，会对作业是否在其他分区运行，是否为hetjob作业（主调度不负责hetjob作业的调度），作业所在分区是否已经加入分区黑名单，作业的QOS是否满足，运行时间是否满足等进行判断，如果作业未通过筛选会直接跳过该作业的调度，继续调度下一个作业。</p>
<p>经过以上筛选，作业符合现在启动的条件，作业会进入select_nodes函数为作业分配节点资源，如果分配成功则调用launch_job启动作业，如果空闲资源不能满足作业需求则跳过该作业调度下一个作业。</p>
<h2 id="select-nodes节点选择流程"><a href="#select-nodes节点选择流程" class="headerlink" title="select_nodes节点选择流程"></a>select_nodes节点选择流程</h2><p>select_nodes函数主要负责将当前空闲资源与作业申请资源进行配，如果匹配成功则能满足作业运行要求，具体流程如下图</p>
<p><img src="/.com//个人博客\MyBlog\source_posts\aaa\sched4.png" alt="sched4"></p>
<p>流程解析</p>
<ol>
<li><p>构建具有必要配置的节点表（node_set_ptr：包含slurm_node.conf中所有节点）；每个表格条目包括它们的权重、节点列表、特征等； </p>
</li>
<li><p>调用_pick_best_nodes，从满足作业规格的所有节点的权重顺序列表中，选择“最佳”以供使用；</p>
</li>
</ol>
<ul>
<li><ul>
<li>如果指定了必需的节点列表，则确定隐式必需的处理器和节点数;</li>
</ul>
</li>
<li><ul>
<li>确定表示了多少不相交的必需“feature”（例如“FS1 | FS2 | FS3”）;</li>
</ul>
</li>
<li><ul>
<li>对于每个feature：查找匹配的节点表条目，识别可用的节点（空闲或共享），并将它们添加到全局的节点bitmap中;</li>
</ul>
</li>
<li><ul>
<li>select_g_job_test（），根据拓扑和&#x2F;或工作负载选择其中的“最佳”; 最佳”定义为连续节点的最小数量，或者如果共享资源，则使用类似大小的作业共享资源。</li>
</ul>
</li>
<li><ul>
<li>如果现在无法满足请求，请对存在于任何状态（DOWN DRAINED ALLOCATED）的节点列表执行select_g_job_test（），以确定是否能够满足请求;</li>
</ul>
</li>
</ul>
<ol>
<li>调用allocate_nodes，执行实际分配节点；</li>
</ol>
<h2 id="分区黑名单流程"><a href="#分区黑名单流程" class="headerlink" title="分区黑名单流程"></a>分区黑名单流程</h2><p>主调度为了保证高优先级作业优先运行引入了分区黑名单的机制，其主干流程如下图</p>
<p><img src="/.com//个人博客\MyBlog\source_posts\aaa\sched5.png" alt="sched5"></p>
<p>流程解析</p>
<ol>
<li><p>主调度不能运行异构作业，如果是异构作业直接加入分区黑名单 </p>
</li>
<li><p>分区avail节点不满足作业运行条件直接加入 </p>
</li>
<li><p>作业调度不成功</p>
</li>
</ol>
<ul>
<li><ul>
<li>空闲资源不足将fail_by_part设置为true</li>
</ul>
</li>
<li><ul>
<li>获取作业的联合集群锁失败将fail_by_part设置为true</li>
</ul>
</li>
<li><ul>
<li>用户配额限制并且设置了assoc_limit_stop参数fail_by_part设置为true</li>
</ul>
</li>
<li><ul>
<li>如果fail_by_part设置为true之后有几种方式可以将fail_by_part设置为false</li>
</ul>
</li>
</ul>
<p>-w制定资源则将指定的资源从avail排除将fail_by_part设置为false </p>
<ul>
<li><ul>
<li>如果是预约的作业将此预约加入分区黑名单将fail_by_part设置为false</li>
</ul>
</li>
<li><ul>
<li>未满足bf_min_age_reserve时间预留将fail_by_part设置为false</li>
</ul>
</li>
<li><ul>
<li>为满足bf_min_prio_reserve优先级预留将fail_by_part设置为false</li>
</ul>
</li>
</ul>
<p>最终如果fail_by_part为true则将作业所在分区加入分区黑名单，如果为false则不加入 </p>
<h1 id="主调度函数调用关系"><a href="#主调度函数调用关系" class="headerlink" title="主调度函数调用关系"></a>主调度函数调用关系</h1><h2 id="函数调用关系"><a href="#函数调用关系" class="headerlink" title="函数调用关系"></a>函数调用关系</h2><p>主调度是在slurmctld服务启动时单独开一个线程负责调度作业，函数调用关系如表，schedule函数入口有很多，不同入口调用被分为全量调度和非全量调度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main  <span class="comment">// controller.c</span></span><br><span class="line">_slurmctld_background  <span class="comment">//主大循环，做很多事情</span></span><br><span class="line">schedule   <span class="comment">//还处理延迟调度操作</span></span><br><span class="line">      _schedule  <span class="comment">// 调度核心部位</span></span><br><span class="line">        select_nodes <span class="comment">// 主要是选择合适节点</span></span><br><span class="line">        srun_allocate <span class="comment">// 处理srun提交的作业</span></span><br><span class="line">          OR</span><br><span class="line">        launch_job   <span class="comment">// 处理sbatch提交的作业</span></span><br></pre></td></tr></table></figure>

<h2 id="全量调度"><a href="#全量调度" class="headerlink" title="全量调度"></a>全量调度</h2><p>全量调度的入口是通过sched_interval参数进行控制，一般设置较大，但是调度是最全面的，代码如下，如果当前时间和上一次全量调度时间间隔大于sched_interval时，会将full_queue设置为true，然后调用schedule函数，full_queue为true是全量调度，在调度过程中不会考虑default_queue_depth的值，也不会因为default_queue_depth受限而退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_slurmctld_background()</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">bool</span> call_schedule = <span class="literal">false</span>, full_queue = <span class="literal">false</span>;</span><br><span class="line">        …</span><br><span class="line">        <span class="keyword">if</span> (difftime(now, last_full_sched_time) &gt;= sched_interval) &#123;</span><br><span class="line">            call_schedule = <span class="literal">true</span>;</span><br><span class="line">            full_queue = <span class="literal">true</span>;</span><br><span class="line">            job_sched_cnt = <span class="number">0</span>;</span><br><span class="line">            last_full_sched_time = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (call_schedule) &#123;</span><br><span class="line">            now = time(<span class="literal">NULL</span>);</span><br><span class="line">            last_sched_time = now;</span><br><span class="line">            bb_g_load_state(<span class="literal">false</span>);	<span class="comment">/* May alter job nice/prio */</span></span><br><span class="line">            <span class="keyword">if</span> (schedule(full_queue))</span><br><span class="line">            	last_checkpoint_time = <span class="number">0</span>; <span class="comment">/* force state save */</span></span><br><span class="line">            set_job_elig_time();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非全量调度"><a href="#非全量调度" class="headerlink" title="非全量调度"></a>非全量调度</h2><ol>
<li>没有设置defer时，当一个作业完成会调用非全量调度代码如下，此时传入的变量为0代表非全量调度，调度时会考虑default_queue_depth的参数，一般default_queue_depth参数设置的比较小，非全量调度会简单调度几个作业之后就会退出</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_slurm_rpc_epilog_complete()</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">	<span class="comment">/* Functions below provide their own locking */</span></span><br><span class="line">	<span class="keyword">if</span> (!(msg-&gt;flags &amp; CTLD_QUEUE_PROCESSING) &amp;&amp; run_scheduler) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * In defer mode, avoid triggering the scheduler logic</span></span><br><span class="line"><span class="comment">		 * for every epilog complete message.</span></span><br><span class="line"><span class="comment">		 * As one epilog message is sent from every node of each</span></span><br><span class="line"><span class="comment">		 * job at termination, the number of simultaneous schedule</span></span><br><span class="line"><span class="comment">		 * calls can be very high for large machine or large number</span></span><br><span class="line"><span class="comment">		 * of managed jobs.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!LOTS_OF_AGENTS &amp;&amp; !defer_sched)</span><br><span class="line">			(<span class="type">void</span>) schedule(<span class="number">0</span>);	<span class="comment">/* Has own locking */</span></span><br><span class="line">		schedule_node_save();		<span class="comment">/* Has own locking */</span></span><br><span class="line">		schedule_job_save();		<span class="comment">/* Has own locking */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>当有作业需要调度时，也会触发非全量调度，这个的激活方式有很多，下面事件都会使job_sched_cnt变量增加，当job_sched_cnt有值且距上次调度的时间间隔超过了batch_sched_delay则会触发一次非全量调度,代码如下</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_slurmctld_background()</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">bool</span> call_schedule = <span class="literal">false</span>, full_queue = <span class="literal">false</span>;</span><br><span class="line">        …</span><br><span class="line">        <span class="keyword">if</span> (difftime(now, last_full_sched_time) &gt;= sched_interval) &#123;</span><br><span class="line">        …</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (job_sched_cnt &amp;&amp;</span><br><span class="line">                    (difftime(now, last_sched_time) &gt;=</span><br><span class="line">                    batch_sched_delay)) &#123;</span><br><span class="line">                    call_schedule = <span class="literal">true</span>;</span><br><span class="line">                    job_sched_cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (call_schedule) &#123;</span><br><span class="line">            now = time(<span class="literal">NULL</span>);</span><br><span class="line">            last_sched_time = now;</span><br><span class="line">            bb_g_load_state(<span class="literal">false</span>);	<span class="comment">/* May alter job nice/prio */</span></span><br><span class="line">            <span class="keyword">if</span> (schedule(full_queue))</span><br><span class="line">           		last_checkpoint_time = <span class="number">0</span>; <span class="comment">/* force state save */</span></span><br><span class="line">            set_job_elig_time();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发job_sched_cnt变量增加的事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>	_start_stage_in</span><br><span class="line"><span class="number">2.</span>	_reset_buf_state</span><br><span class="line"><span class="number">3.</span>	_reconfigure_slurm <span class="comment">//更新配置</span></span><br><span class="line"><span class="number">4.</span>	_slurmctld_background <span class="comment">//主循环</span></span><br><span class="line"><span class="number">5.</span>	_fed_mgr_job_allocate_sib</span><br><span class="line"><span class="number">6.</span>	_has_deadline</span><br><span class="line"><span class="number">7.</span>	_slurm_rpc_allocate_resources <span class="comment">//分配资源</span></span><br><span class="line"><span class="number">8.</span>	_slurm_rpc_node_registration  <span class="comment">//节点注册</span></span><br><span class="line"><span class="number">9.</span>	_slurm_rpc_reconfigure_controller <span class="comment">//更新配置</span></span><br><span class="line"><span class="number">10.</span>	_slurm_rpc_submit_batch_job <span class="comment">//sbatch提交作业</span></span><br><span class="line"><span class="number">11.</span>	_slurm_rpc_update_job <span class="comment">//update更新作业信息</span></span><br><span class="line"><span class="number">12.</span>	_slurm_rpc_update_node <span class="comment">//更新节点状态或信息</span></span><br><span class="line"><span class="number">13.</span>	_slurm_rpc_update_partition <span class="comment">//更新分区配置</span></span><br><span class="line"><span class="number">14.</span>	_slurm_rpc_resv_create  <span class="comment">//创建预留</span></span><br><span class="line"><span class="number">15.</span>	_slurm_rpc_resv_update <span class="comment">//更新预留</span></span><br><span class="line"><span class="number">16.</span>	_slurm_rpc_resv_delete <span class="comment">//删除预留</span></span><br><span class="line"><span class="number">17.</span>	_slurm_rpc_suspend <span class="comment">//挂起作业</span></span><br></pre></td></tr></table></figure>

<h1 id="主调度参数优化方案"><a href="#主调度参数优化方案" class="headerlink" title="主调度参数优化方案"></a>主调度参数优化方案</h1><p>主调度各个配置参数生效位置</p>
<p><img src="/.com//个人博客\MyBlog\source_posts\aaa\sched6.png" alt="sched6"></p>
<p>各个参数在调度中不同的位置发挥不同的作业，但是相互之间有着间接的联系，在不场景下可以通过不同的参数对调度进行限制，参数优化方案如下</p>
<ol>
<li><p>根据集群规模用户数量分区复杂度能得到每个作业调度时间 </p>
</li>
<li><p>最大调度时间不能设置太长也不能设置太短，建议设为3秒，3秒是有点长但是平时作业量少调度一般不是因为超时退出，所以主调度持有锁的时间会小于3秒 </p>
</li>
<li><p>一个作业调度时间知道了，最大调度时间知道了就可以求出一次调度能够调度成功的作业数 </p>
</li>
<li><p>结合分区数量控制分区深度，数值可以根据集群的调度情况来定，比如一个作业的完整调度时间为0.06秒max_sched_time设置为2（一次调度大约30个作业），limit受限的作业每个也需要0.015秒（一次调度大约130个），而分区黑名单或者分区深度达到后直接改状态不怎么耗时，所以分区深度设置太大会导致因为调度超时退出参数不起作用，设置太小又会导致效率太低，可能会因为分区被拉入分区黑名单将分区深度顺序打满，需要保证当作业量大时会因为分区深度受限而调度其他作业，不能因为设置太大导致其他分区饿死 </p>
</li>
<li><p>根据分区数量分区深度合理设置非全量调度深度 </p>
</li>
<li><p>根据每个作业调度时间以及预期作业启动数量能够对调度最小时间间隔和时间间隔进行设定，调度的频率和数量不是关键，关键是调度的质量和启动的作业数，调度间隔时间可以适当增大，根据预期启动作业数计算出做小间隔时间，比如一个小时预期启动2万个作业，每秒启动15个，每次调度2秒(3600&#x2F;(sched_min_interval+2))*30&#x3D;2000；sched_min_interval&#x3D;3.4</p>
</li>
</ol>
<p><img src="/.com//个人博客\MyBlog\source_posts\aaa\sched7.png" alt="sched7"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>主调度是slurm调度系统中的最主要调度策略，要保证集群的响应速度、吞吐量、调度速率和资源的高效利用。 </p>
</li>
<li><p>主调度还要保证高优先级的作业是优先运行的，所以作业队列是按照优先级进行调度。 </p>
</li>
<li><p>众多的调度参数可以对主调度的流程加以限制，各个参数之间存在间接关联性，合理的设计调度参数会对集群的调度效率和集群资源的高效利用有很大的帮助</p>
</li>
</ol>
<p><strong>Slurm调度系统是当前调度系统中少有的开源且成熟的调度系统，但是仍然有少量bug的存在，且不能完全覆盖所有的用户场景，如果您有问题请加入我们  V135-6164-9610</strong></p>
<p><strong>下一篇文章burst buffer技术相关</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">study slurm</p>
  <div class="site-description" itemprop="description">坚持</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">study slurm</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
